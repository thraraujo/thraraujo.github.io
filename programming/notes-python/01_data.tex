%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Data Structures}

\subsection{Lists}

Lists have the form
\begin{verbatim}
> lst = ["a", 1, [], 2.5] 
\end{verbatim}
and you can see that it admits several types of data, including other lists \verb|[ ]|. Moreover, lists are indexed, and the index starts with zero ``0''. The most import point is the methods we can use with lists, and it is the topic I want to discuss now. 

\subsubsection{Methods}

We have the following methods:

\begin{itemize}
	\item Miscellaneous
	\begin{itemize}
		\item index
		\item count
		\item reverse
		\item sort
		\item join\footnote{That, to be precise, is a string method}
		\item slicing
	\end{itemize}
	
	\item Adding data
	\begin{itemize}
		\item append
		\item extend
		\item insert
	\end{itemize}
	
	\item Removing data
	\begin{itemize}
		\item clear
		\item remove
		\item pop\footnote{ We also have the keyword del. It is not a method (and pop and remove). 
            Given a list L, The the keyword del is used as del L[n] where n is an index}.
	\end{itemize}
\end{itemize}

\paragraph{Miscellaneous}

Consider the lis
\begin{verbatim}
> lst = ["A", "B", "C", "D", "E", "E", "E", "E", "F"]
\end{verbatim}

We want to describe the methods we mentioned before. 

\# {\bf index(x, start, end)} This method gives the first instance where the value \verb|'x'| appears in the list. In the list we mentioned above, we have
\begin{verbatim}
> lst.index("A")
0
> lst.index("C")
2
> lst.index("E")
4
\end{verbatim}
Observe that string \verb|"E"| appears in 4 because it is the first time it appears in the list. For this reason, we can add the options to restrict the interval it search for a particular string. For example:
\begin{verbatim}
> lst.index("5",5,7)
5
\end{verbatim}
it gives the first time it appears in the list, starting at the value 5.

\# {\bf count(x)} This method returns the number of times \verb|x| appears in the list. For example:
\begin{verbatim}
> lst.count("A")
1
> lst.count("E")
4
\end{verbatim}
    
\# {\bf reverse()} It reverses the order of the list. For example:
\begin{verbatim}
> lst.reverse()
> lst
['F', 'E', 'E', 'E', 'E', 'D', 'C', 'B', 'A']
\end{verbatim}

\# {\bf sort()} It sorts the elements of the list. For example:
\begin{verbatim}
> lst.reverse()
> lst
['F', 'E', 'E', 'E', 'E', 'D', 'C', 'B', 'A'] 
> lst.sort()
> lst
['A', 'B', 'C', 'D', 'E', 'E', 'E', 'E', 'F']     
\end{verbatim}

\# {\bf join()}
Given a list as above, it makes a string with the entries of the list. The syntax is a bit different now. First I want to define how the entries will be patched, and inside the parenthesis we give the list. Using the list above, we have 
\begin{verbatim}
> "".join(lst)
'ABCDEEEEF'
> " ".join(lst)
'A B C D E E E E F'
> "_".join(lst)
'A_B_C_D_E_E_E_E_F'
> " and ".join(lst)
'A and B and C and D and E and E and E and E and F'
\end{verbatim}        

\# {\bf copy()} It creates a copy of the list. 
\begin{verbatim}
> lst2 = lst.copy()
> lst
['A', 'B', 'C', 'D', 'E', 'E', 'E', 'E', 'F']   
> lst2 
['A', 'B', 'C', 'D', 'E', 'E', 'E', 'E', 'F']
\end{verbatim}

\# {\bf slicing} It has notation given by \verb|[start:end:steps]|. The notation is a but obvious. Consider the list of numbers from 1 to 100, that is 
\begin{verbatim}
> num = list(range(1,101))
\end{verbatim}
now we consider the slice
\begin{verbatim}
> num[3:20]
[4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
\end{verbatim}
Observe that it does not include the number 3. We can consider steps of 4, then
\begin{verbatim}    
> num[3:20:4]
[4, 8, 12, 16, 20]
\end{verbatim}

\paragraph{Adding data}

Consider the list
\begin{verbatim}
> colors = ["red", "purple", "cyan", "yellow", "blue"]
\end{verbatim}

\# {\bf append(x)} It add the element x to the end of the list 
\begin{verbatim}
> colors.append("green")
> colors
['red', 'purple', 'cyan', 'yellow', 'blue', 'green']
\end{verbatim}

\# {\bf extend(x)} It extends the list by appending another list 
\begin{verbatim}
> colors.extend(["brown", "black", "white"])       
> colors
['red', 'purple', 'cyan', 'yellow', 'blue', 'green', 'brown', 'black', 'white']
\end{verbatim}        
        
\# {\bf insert(i, x)} It inserts the element \verb|x| before the element currently at position labeled by \verb|i|. For example, in our case, we want to insert \verb|"pink"| before \verb|'purple'|, which is labeled by \verb|i=1|. We do the following:
\begin{verbatim}
> colors.insert(1, "pink")       
> colors
['red', 'pink', 'purple', 'cyan', 'yellow', 'blue', 'green', 'brown', 'black', 'white']
\end{verbatim}        

\paragraph{Removing data}

Consider the list
\begin{verbatim}
> lst = ['red', 'pink', 'purple', 'cyan', 'yellow', 'blue']
\end{verbatim}

\# {\bf clear()} It does what it says it does.

\# {\bf remove(x)} It removes the first with that matches the entry \verb|x|.

\# {\bf pop([i])} It removes the item at the position \verb|i|, and returns it. For example
\begin{verbatim}
> lst.pop(2)
'purple'
> lst 
['red', 'pink', 'cyan', 'yellow', 'blue']
\end{verbatim}
and we can return to the original list with insert 
\begin{verbatim}
> lst.insert(2, 'purple')
['red', 'pink', 'purple', 'cyan', 'yellow', 'blue']
\end{verbatim}


\subsubsection{List comprehension}

\paragraph{Basic definitions}

It is a shorthand way to build new lists. It has the form
\begin{verbatim}
> [ _ _ _ for _ _ _ in _ _ _ ]
\end{verbatim}
For example:
\begin{verbatim}
> nums = [1, 2, 3, 4]
> lst = [x ** 2 for x in nums ]
[1, 4, 9, 16]
\end{verbatim}

We could also do it with a loop:
\begin{verbatim}
> nums = [1, 2, 3, 4]
> lst = []
> for j in nums:
   	squ = j ** 2

        lst.append(squ)
> print(lst)
\end{verbatim}

Colt made a mistake in the next example:

\begin{verbatim}
> friends = ['ashley', 'matt', 'michael']
> lst = [friend[0].upper() for friend in friends]
['A', 'M', 'M']
\end{verbatim}
Actually, he meant
\begin{verbatim}
> friends = ['ashley', 'matt', 'michael']
> lst = [friend[0].upper() + friend[1:] for friend in friends]
\end{verbatim}
This example is nice because it shows that we can slice the strings. See slice in our previous chapter. 

\paragraph{List comprehension with conditional logic} Here I want to understand important aspects of list comprehension.

{\bf \# for:} It has the form 
\begin{verbatim}
> [ _ _ _ for _ _ _ in _ _ _ if _ _ _ ]
\end{verbatim}
For example, even and odd numbers.
\begin{verbatim}
> numbers = list(range(1,11))
> evens = [num for num in numbers if num % 2 == 0]
> odds = [num for num in numbers if num % 2 != 0]
\end{verbatim}

Let me remove vowels in my name
\begin{verbatim}
> name = "Thiago Rocha Araujo"
> without = [char for char in name if char not in "aeiou"]
> "".join(without)
'Thg Rch Arj'
\end{verbatim}

We could also do it directly inside the join
\begin{verbatim}
> without = " ".join(char for char in name if char not in "aeiou")
\end{verbatim}

Another example from the course. It removes the vowels from the word amazing
\begin{verbatim}
> answer = [letter for letter in "amazing" if letter not in "aeiou"]
\end{verbatim}

Another example
\begin{verbatim}
> numbers = list(range(1,11))
> lst = [ num ** 2 if num % 2 == 0 else num ** 3 for num in numbers]
\end{verbatim}

There is an interesting example in Colt's course. It has solution given by 
\begin{verbatim}
answer = [name[len(name):0:-1] + name[0].lower for name in ["Elie", "Tim", "Matt"]]
\end{verbatim}
Also, \verb|name[::-1].lower()| gives the same result. It takes the names in the list, reverse and changes the capital to lower case. 

{\bf \# else:}

\begin{verbatim}
> [ _ _ _ _ if _ _ _ _ else _ _ _ _ for _ _ _ _ in _ _ _ _]
\end{verbatim}        
For example, we build a list with even squared and odd cubed
\begin{verbatim}
> numbers = list(range(1,11))
> lst = [ num ** 2 if num % 2 == 0 else num ** 3 for num in numbers]
\end{verbatim}

\subsubsection{Nested lists}

These are lists inside lists.

\paragraph{Nested loops} The important point here is how it is indexed. For example:
\begin{verbatim}    
> nested_list = [[1,2,3],[4,5,6],[7,8,9]]
> nested_list[1]
[4,5,6]
> nested_list[1][2]
6
\end{verbatim}
I can also print these values using a loop. Of course, I need two loops. 
\begin{verbatim}
> for l in nested_list:
> 	for val in l:
> 		print(val)
\end{verbatim}

\paragraph{Nested list comprehension} For the list
\begin{verbatim}
> nested_list = [[1,2,3],[4,5,6],[7,8,9]]
\end{verbatim}
let us create a list with squares.
\begin{verbatim}
> [[val ** 2 for val in l] for l in nested_list]
\end{verbatim}

Colt's example: tic tac toe
\begin{verbatim}
[["X" if num % 2 != 0 else "O" for num in range(3)] for val in range(3)]
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Dictionary}

\subsubsection{Basics}

There are some limitations in the lists, so we need to introduce the dictionary. One particular type of limitation is a shopping card, where we need to give the name of the object we want to buy, the amount and price. So, we have three types of data, and we do't want to put 'em all together. For example:
\begin{verbatim}
> instructor = {
"name" : "Colt", 
"owns_dog" : True,
"num_courses" : 4, 
44 : "favorite_number"
}
\end{verbatim}
We can also build a dictionary with the \verb|dict()| function. 
\begin{verbatim}
> cat = dict(name="kitty", age=0.5)
\end{verbatim}
We can also retrieve the information with the brackets. For example, we can write \verb|instructor["name"]| gives \verb|"Colt"|.

\subsubsection{Looping} Consider the dictionary
\begin{verbatim}
> instructor = {
"name" : "Colt", 
"owns_dog" : True,
"num_courses" : 4, 
"favorite_language": "Python,
44 : "favorite_number"
}
\end{verbatim}
The function \verb|.values()| give the values we need, in this case, \verb|"Colt", True, "Python", "favorite_number"|, but it returns as a list (or tuples, I still don't know), that is 
\begin{verbatim}
> instructor.values()
dict_values(["Colt", True, 4, "Python", "favorite_number"])
\end{verbatim}

The keys are similar, but with \verb|.keys()|
\begin{verbatim}
> instructor.keys()
dict_keys(["name", "owns_dog", "num_courses", "favorite_language, 44])
\end{verbatim}

We can access both with \verb|.items()| and we get the tuples. If we want to loop over it, we'll need to give two entries, for example
\begin{verbatim}
> for k,v in instructor.items()
> 	print("{} and {}".format(k,v))
\end{verbatim}

One example of the course:
\begin{verbatim}
> donations = dict(sam=25.0, lena=88.99, chuck=13.0, 
... linus=99.5, stan=150.0, lisa=50.25, harrison=10.0)
> total_donations = 0
> for don in donations.values():
> 	total_donations += don
\end{verbatim}

Advanced solution 1: This solution uses a built-in function called \verb|sum()|. 
\begin{verbatim}
total_donations = sum(donation for donation in donations.values())
\end{verbatim}

Advanced solution 2: An even better solution using the same sum built-in function is just this nice little line:
\begin{verbatim}
total_donations = sum(donations.values())
\end{verbatim}

We can test if a dictionary has a key, we can use:
\begin{verbatim}
> "name" in instructor
True
> "phone" in instructor
False
\end{verbatim}


\subsubsection{Methods}

Fortunately, we don't have as many as in the lists. 
\begin{itemize}
	\item clear
	\item copy
	\item fromkeys
	\item get
	\item pop
	\item update
\end{itemize}

The first two methods are easy, so we start with the third. 

\# {\bf fromkeys} It is a way to create initial dictionaries where we can give entries later. For example, 
\begin{verbatim}
> new_user = {}.fromkeys(['name', 'score', 'email', 'profile bio'], 'unkown')
> new_user
{'name': 'unkown', 'score': 'unkown', 'email': 'unkown', 'profile bio': 'unkown'}
\end{verbatim}

\# {\bf get} It retrieves a key in an object and returns \verb|None| instead of a \verb|keyerror| if the key does not exist.
\begin{verbatim}
> d = dict(a=1, b=2, c=3) (this is equivalent to d = {"a":1, "b":2, "c":3})
> d["a"]
1
> d["b"]
2
> d.get("a")
1
> d.get("b") 
2
> d["teste"]
error
> print(d.get("teste"))
None
\end{verbatim}

\# {\bf pop} Contrary to the lists, now we need to provide an argument, the key we want to remove. 

\# {\bf popitem} It removes an arbitrary entry.

\# {\bf update} It updates the keys and values with another set of keys and values. For example:
\begin{verbatim}
> first = dict(a=1, b=2, c=3, d=4, e=5)
> second = {}
> second.update(first)
> second 
{'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}
\end{verbatim}

We can also overwrite the data
\begin{verbatim}
> second["a"] = "AMAZING"
> second 
{'a': 'AMAZING', 'b': 2, 'c': 3, 'd': 4, 'e': 5}
\end{verbatim}

It does not erase the dictionary, but it adds the list. for example,
\begin{verbatim}
> first 
{'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}
> third = dict(A="oranges", B="bananas")
> third.update(first)
> third
{'A': 'oranges', 'B': 'bananas', 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}
\end{verbatim}

But if I change one value, I can return to the original list with the update. For example:
\begin{verbatim}
> third["a"] = "apples"
> third
{'A': 'oranges', 'B': 'bananas', 'a': 'apples', 'b': 2, 'c': 3, 'd': 4, 'e': 5}
> third.update(first)
> third
{'A': 'oranges', 'B': 'bananas', 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}
\end{verbatim}


\subsubsection{Dictionary comprehension}

\paragraph{Loops}

The syntax is similar to the list syntax, but we have some tweaks.
\begin{verbatim}
> { _ _ _ : _ _ _ for _ _ _ in _ _ _ }
\end{verbatim}
For example
\begin{verbatim}
> numbers = dict(first=1, second=2, third=3)
> squared_numbers = {key: value ** 2 for key, value in numbers.items()}
> squared
{'first': 1, 'second': 4, 'third': 9}
\end{verbatim}

A second example
\begin{verbatim}
> squared_num = {num: num ** 2 for num in [1,2,3,4,5]}
> squared_num
{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
\end{verbatim}

Another example
\begin{verbatim}
> str1 = "ABCDE"
> str2 = "123"
> combo = {str1[i]:str2[i] for i in range(0,len(str2))}
> combo
{'A': '1', 'B': '2', 'C': '3'}
\end{verbatim}

\paragraph{Conditional logic} The syntax is given by
\begin{verbatim}
> { _ _ _ : ( _ _ _ if _ _ _ else _ _ _ ) for _ _ _ in _ _ _ }
> { ( _ _ _ if _ _ _ else _ _ _ ) : _ _ _ for _ _ _ in _ _ _ }
\end{verbatim}
For example
\begin{verbatim}
> num_list = list(range(0,21))
> parity = {num:("even" if num % 2==0 else "odd") for num in num_list}
> parity 
\end{verbatim}

There is a interesting function for list comprehension, the function \verb|zip()| that works as follows. Suppose we have two lists 
\begin{verbatim}
> list1 = ["CA", "NJ", "RI"]
> list2 = ["California", "New Jersey", "Rhode Island"]
> answer = {list1[i] : list2[i] for i in range(3)}
> answer2 = dict(zip(list1,list2))  
> answer == answer2
True
\end{verbatim}

Another example for the function \verb|zip()|
\begin{verbatim}
> person = [["name", "Jared"], ["job", "Musician"], ["city", "Bern"]]
> keys = [person[i][0] for i in range(3)]
> values = [person[i][1] for i in range(3)]
> answer = dict(zip(keys, values))
> answer
{'name': 'Jared', 'job': 'Musician', 'city': 'Bern'}
\end{verbatim}

Another example with \verb|dict|
\begin{verbatim}
> ans1 = {char:0 for char in 'aeiou'}	
> ans2 = dict.fromkeys("aeiou", 0)
> ans1 == ans2
True
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Tuples \& Sets}

\subsubsection{Tuples}

It is an ordered collection or groups and items. It seems like lists but there are a few diffrences. First, we cannot change it after defined, and the syntax is different.
\begin{verbatim}
> x = (1, 2, 3)	
> x[0] = "change me"
ERROR
\end{verbatim}
We use them because they are lighter than lists. The code is safer from bugs. In the function \verb|items()|, the return is a tuple. We access their data with the square bracket as well, similar to the list. We can create elements with the function \verb|tuples|.

Tuples can be used as keys in dictionaries. For example:
\begin{verbatim}
> locations = { 
... (latitude1, longitude1) : "Sao Paulo",
... (latitude2, longitude2) : "Pohang",
... (latitude3, longitude3) : "Bern",
}
\end{verbatim}
Then we can access this data with \verb|locations[(latitude1, longitude1)] = "Sao Paulo"|. 

Looping over tuples is equal to looping over lists. That is all. Moreover, we also have \verb|count()| and \verb|index()| as methods. We can also slice the lists, so things are similar. 

%%%%%%%%%%%% 

\subsubsection{Sets}

There are like formal mathematical sets. So, it is a collection of data without any structure and the elements are unique. Since there are no order, we cannot use indices to access the elements. The syntax uses curly brackets. 
\begin{verbatim}
> s = set({1,2,3,4,5,5})
> r = {1,2,3,4,5}	
> s
{1,2,3,4,5}
> s == r
True
> 5 in s
True
\end{verbatim}

\paragraph{Methods}

There are some important methods to discuss with sets. 

\# {\bf add(`x').} It adds a new element \verb|x|. 

\# {\bf remove(`x').} It removes the element \verb|x|. 

\# {\bf discard(`x').} It removes the element \verb|x|, but does not give an error if the element \verb|x| is not present in the set.  

\# {\bf copy().} It creates a copy of the set. 

\# {\bf clear().} It is obvious as well

\paragraph{Mathematical Sets}

These are the data I am interested in. Now we can consider union, intersection and other mathematical operations. 

Consider two classes:
\begin{verbatim}
> math_students = {"Bashir", "Odo", "Sisko", "Worf", "Picard", "Quark"}
> biology_students = {"The Doctor", "Sisko", "Worf", "Seven of Nine", "Data"}
> union_students = math_students | biology_students
{'Seven of Nine', 'Sisko', 'Worf', 'Quark', 'Data', 
'The Doctor', 'Picard', 'Odo', 'Bashir'}
> intersection_students = math_students & biology_students
{'Worf', 'Sisko'}
\end{verbatim}

\paragraph{Set comprehension}

It has the form 
\begin{verbatim}
> { _ _ _ for _ _ _ in _ _ _ }
\end{verbatim}

For example, 
\begin{verbatim}
> { x ** 2 for x in range(10) }
{0, 1, 64, 4, 36, 9, 16, 49, 81, 25}
\end{verbatim}
