\section{Fundamental aspects}

These notes are written from the course of Colt Steele on Git and Github.

\subsection{Username \& Email}

Here I want to define the username and email to my git repositories. 
First thing we do it the following
\begin{verbatim}
> git config --global user.name "NAME"
> git config --global user.email "E-MAIL"
\end{verbatim}
that define, respectively, the username and email. We can change it anytime we want, 
but keep it consistent. We can check it with
\begin{verbatim}
> git confic user.name
> git confic user.email
\end{verbatim}

\subsection{First Commands}

\subsubsection{Status} The first thing we need to understand is the command 
\begin{verbatim}
> git status
\end{verbatim}
It gives information on the current status of a git repository and its contents. 

\subsubsection{Init} The next command is 
\begin{verbatim}
> git init
\end{verbatim}
It makes the directory we are in a git repository. We run this command one time per project. 

The init creates a directory .git (it is hidden). If we delete this folder, 
it destroys the git history, so the directory is not a repository anymore. 
A common git mistake is the following: Once we create a repository, git watches 
everything that happens in the repository, even the creation of nested folders. 
For this reason, we do not run the git init in a folder inside a repository, 
it avoids mistakes.

\subsection{Commiting}

\subsubsection{Add} Now we want to commit the modifications we do on our projects.
\begin{verbatim}
> git add file1 file2 file3
\end{verbatim}
Once we have modified our project, we can pack the modifications or part 
of them using the add command. 

Also, we can add all modifications at once with 
\begin{verbatim}
> git add .
\end{verbatim}


\subsubsection{Commit}

Now we can commit the modifications we have done. 
\begin{verbatim}
> git commit
\end{verbatim}
In this option, we will need to provide the message using vim. 
Or we can write the message as follows
\begin{verbatim}
> git commit -m "my message"
\end{verbatim}

\subsubsection{Log}

It is very straightforward. This command gives a log of commits of a project. 
\begin{verbatim}
> git log    
\end{verbatim}

There are many options available (see documentation). One particular 
useful option is the following
\begin{verbatim}
> git log --abbrev-commit    
\end{verbatim}
that gives a shorter commit name. Another useful option is 
\begin{verbatim}
> git log --oneline    
\end{verbatim}
It gives a short version of the commit message.

\subsubsection{Amend}

Suppose we want to fix a mistake we make in a previous commit. Then we can do the following
\begin{listing}{1}
> git commit -m 'some message'
> git add forgotten_file 
> git commit --amend
\end{listing}

\subsubsection{Gitignore}

Here I just add the file \verb|.gitignore| and list the files and folders 
we do not want to track. 
There are several patterns to follow.Some patterns are 
\begin{listing}{1}
.DS_Store # it ignores files called .DS_Store
folderName/ # It ignores an entire directory
*.log # it ignores everything with the .log extension
\end{listing}

\subsection{Branching}

This is one of the last fundamental tool we learn in git. Everything 
else is secondary. The idea here is that if we need to modify our project, 
or work simultaneously with other people, we can create other branches 
of the project and merge them afterwards.

The default branch when we create a repository -- that is, when we git init -- 
is called \verb|master branch|. When we type \verb|git log|, we see that 
the most recent \verb|commit| is called \verb|HEAD|. As a matter of the fact, 
it is written something of the form \verb|HEAD -> master|. It refers
to the thing we are currently working.

\subsubsection{Git branch}

Here we can start with our first command. It is 
\begin{listing}{1}
> git branch
\end{listing}
that gives the existing branches in our repository. Moreover, the \verb|*| 
indicates our current branch.

\subsubsection{Creating and switching branches}

In order to create new branches, we use the same syntax, except that now 
we add the name of the branch, that is
\begin{listing}{1}
> git branch <new_branch>
\end{listing}
Observe that this command just creates another branch for us, 
but it does not change our work to the new branch. We can change the brach with
\begin{listing}{1}
> git switch <branch_name>
\end{listing}
It is important to notice that this command creates a new branch based on the current head.

There are another command to switch between branches, it is 
\begin{listing}{1}
> git checkout <branch_name>
\end{listing}   
This command does a zillion other things, so the \verb|switch| 
was introduced to be a simpler alternative. 

Finally, we can create a switch to the new branch at once; 
we just need to introduce a flag \verb|-c|, 
\begin{listing}{1}
> git switch -c <branch_name>
> git checkout -b <branch_name>
\end{listing} 

Finally, there is something important we need to understand. If we switch to new 
branches without committing the modifications, these would be lost. So, we need 
to commit (or stash them) them, and just after that we switch to new branches. 
Actually, sometimes, when the files do not exist in other branches - and there 
is no risk of conflicts - the files follow us to the new branch.

\subsubsection{Deleting and renaming branches}

We can delete the branch with the command 
\begin{listing}{1}
> git branch -d <branch_name>
\end{listing}   
It works if the branch is fully merged. Otherwise,  
instead the \verb|-d|, we can put \verb|-D| which denotes \verb|force|. We cannot delete inside the branch.

Moreover, we can rename the branch with
\begin{listing}{1}
> git branch -m <new_branch_name>
\end{listing}
In order to rename, we need to be inside the branch.

\subsection{Merging branches}

Finally, we have the last fundamental concept of git: Merging different branches. We need to 
keep in mind that the master brach should not be used for experiments; in other words, we must use 
the master branch just for ``permanent'' coding. 

This discussion ps somewhat straightforward. We use the following command 
\begin{listing}{1}
> git merge <name_modified_branch> 
\end{listing}
We need to be in the branch we want to update. Moreover, it is worth noticing that the merge is 
temporary, and it means that no branch is destroyed in the process. 

On the other hand, there are at least three different situations we need to distinguish when we 
merge branches.

\subsubsection{Fast-forward}

The first case is very easy. It is basically the case where the older commit is kept as it was, 
and the new branch basically adds new information. In this case, the commit just brings the old 
commit to a new point, and the two branches are similar. Evidently, if we change any branch, they 
diverges again. Remember that we need to switch to the branch we need to update, and  

\subsubsection{Merging without conflicts}

The second type of merging is that when two branches are modified, but no conflicts are found. 
It happens, for example, when the branches touch different files or add new files. 

In this case, git creates a new commit unifying all modifications.

\subsubsection{Merging with conflicts}

The last case is when there are conflicts. In this case, git denounces the conflicts, and we need 
to manually resolve them.





